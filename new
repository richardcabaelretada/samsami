const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');
const sqlite3 = require('sqlite3').verbose();
const stringSimilarity = require('string-similarity');

const app = express();

const downloadFile = async (url, filePath) => {
  const response = await axios({
    url,
    method: 'GET',
    responseType: 'stream'
  });

  const writer = fs.createWriteStream(filePath);

  return new Promise((resolve, reject) => {
    response.data.pipe(writer);
    writer.on('finish', resolve);
    writer.on('error', reject);
  });
};

const initializeDatabase = async () => {
  const dbPath = path.join(__dirname, 'sim', 'data', 'data.sqlite');
  const db = new sqlite3.Database(dbPath);

  // Create the data table if it doesn't exist
  await new Promise((resolve, reject) => {
    db.run(`
      CREATE TABLE IF NOT EXISTS data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ask TEXT,
        ans TEXT
      )
    `, (err) => {
      if (err) reject(err);
      resolve();
    });
  });

  db.close();
};

const fetchDataFromDatabase = async (type, ask) => {
  const dbPath = path.join(__dirname, 'sim', 'data', 'data.sqlite');
  const db = new sqlite3.Database(dbPath);

  return new Promise((resolve, reject) => {
    db.all(`SELECT * FROM data WHERE ask = ?`, [ask], (err, rows) => {
      if (err) reject(err);
      resolve(rows);
    });
  });
};

const getRandomAnswerFromSimilarAsks = async (ask) => {
  const dbPath = path.join(__dirname, 'sim', 'data', 'data.sqlite');
  const db = new sqlite3.Database(dbPath);

  return new Promise((resolve, reject) => {
    db.all(`SELECT * FROM data WHERE ask LIKE ? ORDER BY RANDOM() LIMIT 1`, [`%${ask}%`], (err, rows) => {
      if (err) reject(err);
      resolve(rows);
    });
  });
};

const getRandomAnswer = (ans) => {
  const answers = JSON.parse(ans);
  return answers[Math.floor(Math.random() * answers.length)];
};

app.get('/sim/simv3', async (req, res) => {
  if (!req.query.type) return res.json({ error: 'lack of data to launch' });

  if (req.query.type === 'ask') {
    const ask = encodeURI(req.query.ask);
    if (!ask) return res.json({ error: 'missing data to launch the program' });

    try {
      const dataRows = await fetchDataFromDatabase(req.query.type, ask);
      if (dataRows.length === 0) {
        const similarAsks = await getRandomAnswerFromSimilarAsks(ask);
        if (similarAsks.length > 0) {
          const answer = getRandomAnswer(similarAsks[0].ans);
          return res.jsonp({ answer });
        } else {
          // If no similar asks found, get any random answer
          const randomRow = await getRandomAnswerFromSimilarAsks('');
          const answer = getRandomAnswer(randomRow[0].ans);
          return res.jsonp({ answer });
        }
      }

      const msg = dataRows.map(row => row.ask);
      const checker = stringSimilarity.findBestMatch(decodeURI(ask), msg);
      if (checker.bestMatch.rating >= 0.1) {
        const search = checker.bestMatch.target;
        const findRows = await fetchDataFromDatabase(req.query.type, search);

        if (findRows.length === 0) {
          const randomSimilarAsk = await getRandomAnswerFromSimilarAsks(search);
          const answer = getRandomAnswer(randomSimilarAsk[0].ans);
          return res.jsonp({ answer });
        }

        const randomRow = findRows[Math.floor(Math.random() * findRows.length)];
        const answer = getRandomAnswer(randomRow.ans);
        return res.jsonp({ answer });
      } else {
        const randomRow = await getRandomAnswerFromSimilarAsks('');
        const answer = getRandomAnswer(randomRow[0].ans);
        return res.jsonp({ answer });
      }
    } catch (error) {
      console.error(error);
      return res.json({ error: 'Internal server error' });
    }
  }

  if (req.query.type === 'teach') {
    const ask = req.query.ask;
    const ans = req.query.ans;
    if (!ask || !ans) return res.json({ error: 'missing data to execute the command' });

    try {
      const dataRows = await fetchDataFromDatabase(req.query.type, ask);

      if (dataRows.length > 0) {
        const existingAns = JSON.parse(dataRows[0].ans);
        if (existingAns.includes(ans)) return res.json({ error: 'The answer already exists!' });

        existingAns.push(ans);

        await new Promise((resolve, reject) => {
          const dbPath = path.join(__dirname, 'sim', 'data', 'data.sqlite');
          const db = new sqlite3.Database(dbPath);

          db.run('UPDATE data SET ans = ? WHERE ask = ?', [JSON.stringify(existingAns), ask], (err) => {
            if (err) reject(err);
            resolve();
          });

          db.close();
        });
      } else {
        await new Promise((resolve, reject) => {
          const dbPath = path.join(__dirname, 'sim', 'data', 'data.sqlite');
          const db = new sqlite3.Database(dbPath);

          db.run('INSERT INTO data (ask, ans) VALUES (?, ?)', [ask, JSON.stringify([ans])], (err) => {
            if (err) reject(err);
            resolve();
          });

          db.close();
        });
      }

      return res.json({
        msg: 'Teach sim success',
        data: { ask, ans }
      });
    } catch (error) {
      console.error(error);
      return res.json({ error: 'Internal server error' });
    }
  }
});

app.get('/', (req, res) => {
  res.send('<h1>Hello, World!</h1>');
});

const startServer = async () => {
  await initializeDatabase();

  const PORT = process.env.PORT || 2014;
  app.listen(PORT, '0.0.0.0', () => {
    console.log(`Server is listening on port ${PORT}`);
  });
};

startServer();
